# 1. 什么是所有域 What Is Ownership?
Rust 一个主要的特性就是所有权(ownership)。尽管这个特性

所有的程序都必须在运行程序的时候管理他们所用的内存。某些语言有垃圾回收的功能，这种垃圾回收机制会不断的寻找不再被使用的内存。还有别的语言，开发者必须要显式的分配和释放内存。Rust 用了一个第三种的途径: 通过拥有一整套在编译的时候检查的规则的 **所有权系统** 来管理内存。
这对于开发者来说是一个好消息，也是一个坏消息。坏消息是因为所有权对于大多数的开发者来说是个全新的概念，所以需要花一些时间才能习惯；而好消息就是，一旦你适应了这个**所有权系统**，你就能开发出安全高效的代码。
当你彻底明白了所有区安全之后，你会对 Rust 独树一帜的功能的有更深层次的理解。在本章中，你会通过一些字符串的示例来学习 **所有权**。

> ### 栈与堆 The Stack and the Heap
> 在很多编程语言中，你不用过多的考虑关于堆和栈。但是像 Rust 这个一个系统编程语言中，一个值在堆中还是在栈中会对这个值接下来的行为以及做出正确抉择产生巨大的影响。所有权的部分会在本章的后面的堆和栈中介绍。这个只是做一个简要的说明。
> 

### 1.1 Ownership Rules

### 1.2 Variable Scope

### 1.3 The String Type
我们需要一个比较复杂的数据类型来说明所有域(ownership)的规则，这种数据结构要比之前的第3章“数据类型” 一节中的数据类型更加复杂。前面的介绍的那些数据类型都是保存在栈中的，我们更像知道数据是如何保存在堆中的，并且弄明白 Rust 是何时，通过何种方式清理这些数据的。
我们这里以 `String` 这个数据类型作为示例，并且集中讨论和所有域相关的字符串的部分的内容。当然讨论这些概念也同样适用于别的复杂的数据类型，不管它们是标准库提供的还是你自己创建的数据类型。

```rust
fn main() {
    let s = String::from("hello");
}
```

```rust
fn main() {
    let mut s = String::from("hello");
    s.push_str(", world!"); // push_str() appends a literal to a String
    println!("{}", s); // This will print `hello, world!`
}
```


### 1.4 Memory and Allocation
##### 1.4.1 变量和数据交互的方式: 移动 (Ways Variables and Data Interact: Move)

![在这里插入图片描述](pic/ch04/trpl04-01.svg)

##### 1.4.2 Ways Variables and Data Interact: Clone


##### 1.4.3 Stack-Only Data: Copy



### 1.5 Ownership and Functions
Ownership and Functions
```rust
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it’s okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.

```

### 1.6 Return Values and Scope

# 2. References and Borrowing
Here is how you would define and use a calculate_length function that has a reference to an object as a parameter instead of taking ownership of the value:
获取一个对象的引用，不是获取这个变量的所有权，也就是得到这个对象的值？

```java
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}

```

We call having references as function parameters borrowing. As in real life, if a person owns something, you can borrow it from them. When you’re done, you have to give it back.

So what happens if we try to modify something we’re borrowing? Try the code in Listing 4-6. Spoiler alert: it doesn’t work!

### 2.1 可变引用 Mutable References
我们只需要稍稍修改就可以解决 代码清单4-6 中的错误了:
```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
首先，我们必须修改 变量 `s` 为可变的 `mut`，

### 2.2 悬挂引用 Dangling References



# 3 The Slice Type
另一个不是没有所有权的是 *切片*。切片让你可以引用到集合中连续的元素序列，而不是整个集合。
这里有小问题：编写一个函数，这个函数必须要使用一个字符串并起返回这个在这个字符串中找到的第一个单词。如果这个函数没有在这个字符串中找到一个空格，那么整个字符串就被看作是一个单词，那么就要返回整个字符串。
让我们想想这个函数的签名：
```rust
fn first_word(s : &String) -> ?
```

### String Slices

###### String Literals Are Slices

##### String Slices as Parameters

### Other Slices


### Summary