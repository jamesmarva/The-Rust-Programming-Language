# 1. 什么是所有域 What Is Ownership?
Rust 一个主要的特性就是所有权(ownership)。尽管这个特性

所有的程序都必须在运行程序的时候管理他们所用的内存。某些语言有垃圾回收的功能，这种垃圾回收机制会不断的寻找不再被使用的内存。还有别的语言，开发者必须要显式的分配和释放内存。Rust 用了一个第三种的途径: 通过拥有一整套在编译的时候检查的规则的 **所有权系统** 来管理内存。
这对于开发者来说是一个好消息，也是一个坏消息。坏消息是因为所有权对于大多数的开发者来说是个全新的概念，所以需要花一些时间才能习惯；而好消息就是，一旦你适应了这个**所有权系统**，你就能开发出安全高效的代码。
当你彻底明白了所有区安全之后，你会对 Rust 独树一帜的功能的有更深层次的理解。在本章中，你会通过一些字符串的示例来学习 **所有权**。

> ### 栈与堆 The Stack and the Heap
> 在很多编程语言中，你不用过多的考虑关于堆和栈。但是像 Rust 这个一个系统编程语言中，一个值在堆中还是在栈中会对这个值接下来的行为以及做出正确抉择产生巨大的影响。所有权的部分会在本章的后面的堆和栈中介绍。这个只是做一个简要的说明。
> 

### 1.1 Ownership Rules

### 1.2 Variable Scope

### 1.3 The String Type
我们需要一个比较复杂的数据类型来说明所有域(ownership)的规则，这种数据结构要比之前的第3章“数据类型” 一节中的数据类型更加复杂。前面的介绍的那些数据类型都是保存在栈中的，我们更像知道数据是如何保存在堆中的，并且弄明白 Rust 是何时，通过何种方式清理这些数据的。
我们这里以 `String` 这个数据类型作为示例，并且集中讨论和所有域相关的字符串的部分的内容。当然讨论这些概念也同样适用于别的复杂的数据类型，不管它们是标准库提供的还是你自己创建的数据类型。

```rust
fn main() {
    let s = String::from("hello");
}
```

```rust
fn main() {
    let mut s = String::from("hello");
    s.push_str(", world!"); // push_str() appends a literal to a String
    println!("{}", s); // This will print `hello, world!`
}
```


### 1.4 Memory and Allocation
##### 1.4.1 变量和数据交互的方式: 移动 (Ways Variables and Data Interact: Move)

![在这里插入图片描述](pic/ch04/trpl04-01.svg)

##### 1.4.2 Ways Variables and Data Interact: Clone


##### 1.4.3 在栈上的数据：复制(Stack-Only Data: Copy)


### 1.5 所有权和函数 (Ownership and Functions)
把值传给函数的语义和给变量赋值的语义很相似。就像赋值一样，把变量传给一个函数的时候，数值会发生复制，或者移动（我想称之为搬家）。在代码清单4-3 中有一个带有注释的例子，其中显示了变量进入和离开作用域(scope)的位置。
```rust
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function..
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it’s okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
```
↑ 代码清单 4-3：带有注释的函数所有权和作用域的代码

如果我们在调用了 `takes_ownership` 函数之后再去调用变量 `s`，Rust 会抛出一个编译时的错误。这些静态检查可以防止我们放错误。尝试添加 使用 `s` 和 `x` 的代码到main函数中，以查看他们在何处使用他们，以及在何处所有权的规则会阻止你使用这些变量。

### 1.6 返回 值和作用域 (Return Values and Scope)
返回值的时候同样也会把所有权返回。代码清单 4 - 4 是和 4-3 一样的带有注释的示例。
```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
  // moved, so nothing happens. s1 goes out of scope and is dropped.

fn gives_ownership() -> String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from("hello"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// takes_and_gives_back will take a String and return one
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
```
↑ 代码清单 4-4：转移返回值的所有权

变量的所有权 每时每刻都遵循相同的模式的：把一个值赋值给另一个变量就会发生移动(搬家)。当指向堆中的数据的变量超过了作用域的时候，那么就会被 `drop` 函数清除变量了，除非该数据已经被转移给另一个变量。

每个函数都获取所有权然后返回所有是非常繁琐的操作。如果我们仅仅是让函数使用变量的值而不是所有权怎么办？令人十分烦恼的是，我们如果想在再次使用这个变量的所有权并且让函数的主题不产生任何额外的数据，那么我们值只能返回它。
可以用元组来返回多个值，请看代码清单 4-5：
```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
```
↑ 代码清单 4-5：返回参数的所有权
对于这样一个普遍的功能来说，这样的入参和返回有太多的不方便了，比如每次都要用元组把所有权和别的返回值一起返回，这样明显不方便。幸好Rust有一个解决的方法，那就是“Reference” 


# 2. 引用和借用 References and Borrowing
Here is how you would define and use a calculate_length function that has a reference to an object as a parameter instead of taking ownership of the value:
获取一个对象的引用，不是获取这个变量的所有权，也就是得到这个对象的值？

```java
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

We call having references as function parameters borrowing. As in real life, if a person owns something, you can borrow it from them. When you’re done, you have to give it back.

So what happens if we try to modify something we’re borrowing? Try the code in Listing 4-6. Spoiler alert: it doesn’t work!

### 2.1 可变引用 Mutable References
我们只需要稍稍修改就可以解决 代码清单4-6 中的错误了:
```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
首先，我们必须修改 变量 `s` 为可变的 `mut`，

### 2.2 悬挂引用 Dangling References

# 3 切片类型 (The Slice Type)
另一种没有所有权的数据类型是 *切片*。切片让你可以引用到集合中部分连续的元素序列，而不是整个集合。
先来看看一个编程的小问题，：编写一个函数，传入一个字符串变量，然后返回一个在字符串中找到的第一个单词。如果这个函数没有在这个字符串中找到一个空格，那么整个字符串就被看作是一个单词，那么就要返回整个字符串。
这里有小问题：编写一个函数，这个函数必须要使用一个字符串并起返回这个在这个字符串中找到的第一个单词。如果这个函数没有在这个字符串中找到一个空格，那么整个字符串就被看作是一个单词，那么就要返回整个字符串。
先来看看这个函数的签名：
```rust
fn first_word(s : &String) -> ?
```
这个函数`first_word`，有一个 `&String` 类型的参数。我们不想要这个参数的所有权，同时也可以使用这个变量的数据，所以这样做很符合我们的需求。但是我们要返回什么？我们现在还没办法返回字符串的一个*部分*(因为还没学)。但是我们可以返回这个单词的最后一个字母所在的索引。就像 代码4-7 里面写的那样。
```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
fn main() {}
```
Listing 4-7: 这个方法返回字符串的的首个单词的最后的一个索引

因为我们需要逐个检查 `String` 的元素，并且同时检查是否为空格，所以要需要先用 `as_bytes` 把字符串`String` 转换为一个字节的数组
```rust
let bytes = s.as_bytes();
```
接着，我们用 `iter` 方法 创建了一个字节数组的迭代器：
```rust
for (i, &item) in bytes.iter().enumerate() {
```
我们会在的第十三章讨论更多关于 迭代器(iterators)的细节。现在，只要知道迭代器会返回集合里每个元素，并且每个元素都是用枚举来包装的，并且是作为一个元组来返回的。第一个在元组里的整型是 索引(index()，第二个是元素的引用(reference)。这个比自己去计算索引要方便一些。
因为 `enumerate`方法返回的是个元组，所以，我们可以用一些模式来破坏这个元祖。所以在 `for` 循环中，我们用了一个方法方式来使用的 `i` 的来通过索引的方式来使用数组的元素，以及用 `&item` 来使用元组中的单个字节数据，因为我们用 `.iter().enumerate()` 得到了元素的引用，所以我们可以用 `&` 在模式中。
在`for`循环中的，我们不断通过字节文字语法(the byte literal syntax)来判断一个字符是否是空格。如果找到了空格，我们就要返回这位置。否则我们就会用 `s.len()` 来返回字符串的长度。
```rust
    if item == b' ' {
        return i;
    }
}
s.len()
```
我们现在有了找到字符串里的第一个单词末尾的索引的方法，但是依然存在问题。我们返回了一个 `usize` 类型的值，这个值只是在有 `&String`的上下文中有意义的。换句话说，如果脱离了 `String` 类型，那么它就变的毫无意义了。比如在代码4-8里面的代码写的那样：
```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}

fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word will get the value 5

    s.clear(); // this empties the String, making it equal to ""

    // word still has the value 5 here, but there's no more string that
    // we could meaningfully use the value 5 with. word is now totally invalid!
}
```
Listing 4-8: Storing the result from calling the first_word function and then changing the String contents

上面这段代码可以通过编译，就算是我们在 调用了 `s.clear()` 之后继续使用 变量 `word`，也依然不会报错，因为这个数字和 `s` 的状态无关的，`word` 依然是保存着 `5`。我们可以用 这个数字来提取出第一个单词，但是如果字符串的内容发生了改变的话，那么，我们依然用 `5` 这个值来提取首个单词就会产生bug了。
担心 `word` 中的索引会和 `s` 中的数据同步问题是很无聊，而且很容易出错的。如果我们再写一个函数来找出第二个单词，那么管理这些索引的难度就会更大，注意，这里我们的目的是从字符串中获取到单词，所以才去管理这些单词的索引位置的，如果用索引的思路去解决获取字符串中的第二个单词的问题，那么函数的前面就会像下面那样：
```rust
fn second_word(s: &String) -> (usize, usize) {
```
现在我们还必须要实时的跟踪单词的开始索引和结束索引，并且这些值还是在字符串某个状态下面产生的，和字符串的状态没有同步关系。这样一来，我们为了获取字符串里的第一和第二个单词就需要去手动同步是哪个变量，非常麻烦。
幸好，Rust 有个不错的方案来解决这个问题：字符串切片(string slices)。

### 字符串切片(String Slices)


###### String Literals Are Slices

##### String Slices as Parameters

### Other Slices


### Summary

