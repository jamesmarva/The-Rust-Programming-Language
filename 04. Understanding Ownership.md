# 1. 什么是所有域 What Is Ownership?


> 栈与堆 The Stack and the Heap
>

### 1.1 Ownership Rules

### 1.2 Variable Scope

### 1.3 The String Type
我们需要一个比较复杂的数据类型来说明所有域(ownership)的规则，这种数据结构要比之前的第3章“数据类型” 一节中的数据类型更加复杂。前面的介绍的那些数据类型都是保存在栈中的，我们更像知道数据是如何保存在堆中的，并且弄明白 Rust 是何时，通过何种方式清理这些数据的。
我们这里以 `String` 这个数据类型作为示例，并且集中讨论和所有域相关的字符串的部分的内容。当然讨论这些概念也同样适用于别的复杂的数据类型，不管它们是标准库提供的还是你自己创建的数据类型。

```rust
fn main() {
    let s = String::from("hello");
}
```

```rust
fn main() {
    let mut s = String::from("hello");
    s.push_str(", world!"); // push_str() appends a literal to a String
    println!("{}", s); // This will print `hello, world!`
}
```


### 1.4 Memory and Allocation
##### 1.4.1 变量和数据交互的方式: 移动 (Ways Variables and Data Interact: Move)

![在这里插入图片描述](pic/ch04/trpl04-01.svg)

##### 1.4.2 Ways Variables and Data Interact: Clone


##### 1.4.3 Stack-Only Data: Copy



### 1.5 Ownership and Functions
Ownership and Functions
```rust
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it’s okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.

```

### 1.6 Return Values and Scope

# 2. References and Borrowing
Here is how you would define and use a calculate_length function that has a reference to an object as a parameter instead of taking ownership of the value:
```java
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}

```


### 2.1 可变引用 Mutable References
我们只需要稍稍修改就可以解决 代码清单4-6 中的错误了:
```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
首先，我们必须修改 变量 `s` 为可变的 `mut`，

### 2.2 悬挂引用 Dangling References



# 3 The Slice Type



