# 1. 什么是所有域 What Is Ownership?
Rust 一个主要的特性就是所有权(ownership)。尽管这个特性

所有的程序都必须在运行程序的时候管理他们所用的内存。某些语言有垃圾回收的功能，这种垃圾回收机制会不断的寻找不再被使用的内存。还有别的语言，开发者必须要显式的分配和释放内存。Rust 用了一个第三种的途径: 通过拥有一整套在编译的时候检查的规则的 **所有权系统** 来管理内存。
这对于开发者来说是一个好消息，也是一个坏消息。坏消息是因为所有权对于大多数的开发者来说是个全新的概念，所以需要花一些时间才能习惯；而好消息就是，一旦你适应了这个**所有权系统**，你就能开发出安全高效的代码。
当你彻底明白了所有区安全之后，你会对 Rust 独树一帜的功能的有更深层次的理解。在本章中，你会通过一些字符串的示例来学习 **所有权**。

> ### 栈与堆 The Stack and the Heap
> 在很多编程语言中，你不用过多的考虑关于堆和栈。但是像 Rust 这个一个系统编程语言中，一个值在堆中还是在栈中会对这个值接下来的行为以及做出正确抉择产生巨大的影响。所有权的部分会在本章的后面的堆和栈中介绍。这个只是做一个简要的说明。
> 

### 1.1 Ownership Rules

### 1.2 Variable Scope

### 1.3 The String Type
我们需要一个比较复杂的数据类型来说明所有域(ownership)的规则，这种数据结构要比之前的第3章“数据类型” 一节中的数据类型更加复杂。前面的介绍的那些数据类型都是保存在栈中的，我们更像知道数据是如何保存在堆中的，并且弄明白 Rust 是何时，通过何种方式清理这些数据的。
我们这里以 `String` 这个数据类型作为示例，并且集中讨论和所有域相关的字符串的部分的内容。当然讨论这些概念也同样适用于别的复杂的数据类型，不管它们是标准库提供的还是你自己创建的数据类型。

```rust
fn main() {
    let s = String::from("hello");
}
```

```rust
fn main() {
    let mut s = String::from("hello");
    s.push_str(", world!"); // push_str() appends a literal to a String
    println!("{}", s); // This will print `hello, world!`
}
```


### 1.4 Memory and Allocation
##### 1.4.1 变量和数据交互的方式: 移动 (Ways Variables and Data Interact: Move)

![在这里插入图片描述](pic/ch04/trpl04-01.svg)

##### 1.4.2 Ways Variables and Data Interact: Clone


##### 1.4.3 在栈上的数据：复制(Stack-Only Data: Copy)


### 1.5 所有权和函数 (Ownership and Functions)
把值传给函数的语义和给变量赋值的语义很相似。就像赋值一样，把变量传给一个函数的时候，数值会发生复制，或者移动（我想称之为搬家）。在代码清单4-3 中有一个带有注释的例子，其中显示了变量进入和离开作用域(scope)的位置。
```rust
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function..
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it’s okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
```
↑ 代码清单 4-3：带有注释的函数所有权和作用域的代码

如果我们在调用了 `takes_ownership` 函数之后再去调用变量 `s`，Rust 会抛出一个编译时的错误。这些静态检查可以防止我们放错误。尝试添加 使用 `s` 和 `x` 的代码到main函数中，以查看他们在何处使用他们，以及在何处所有权的规则会阻止你使用这些变量。

### 1.6 返回 值和作用域 (Return Values and Scope)
返回值的时候同样也会把所有权返回。代码清单 4 - 4 是和 4-3 一样的带有注释的示例。
```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
  // moved, so nothing happens. s1 goes out of scope and is dropped.

fn gives_ownership() -> String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from("hello"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// takes_and_gives_back will take a String and return one
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
```
↑ 代码清单 4-4：转移返回值的所有权

变量的所有权 每时每刻都遵循相同的模式的：把一个值赋值给另一个变量就会发生移动(搬家)。当指向堆中的数据的变量超过了作用域的时候，那么就会被 `drop` 函数清除变量了，除非该数据已经被转移给另一个变量。

每个函数都获取所有权然后返回所有是非常繁琐的操作。如果我们仅仅是让函数使用变量的值而不是所有权怎么办？令人十分烦恼的是，我们如果想在再次使用这个变量的所有权并且让函数的主题不产生任何额外的数据，那么我们值只能返回它。
可以用元组来返回多个值，请看代码清单 4-5：
```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
```
↑ 代码清单 4-5：返回参数的所有权
对于这样一个普遍的功能来说，这样的入参和返回有太多的不方便了，比如每次都要用元组把所有权和别的返回值一起返回，这样明显不方便。幸好Rust有一个解决的方法，那就是“Reference” 


# 2. 引用和借用 References and Borrowing
Here is how you would define and use a calculate_length function that has a reference to an object as a parameter instead of taking ownership of the value:
获取一个对象的引用，不是获取这个变量的所有权，也就是得到这个对象的值？

```java
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

We call having references as function parameters borrowing. As in real life, if a person owns something, you can borrow it from them. When you’re done, you have to give it back.

So what happens if we try to modify something we’re borrowing? Try the code in Listing 4-6. Spoiler alert: it doesn’t work!

### 2.1 可变引用 Mutable References
我们只需要稍稍修改就可以解决 代码清单4-6 中的错误了:
```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
首先，我们必须修改 变量 `s` 为可变的 `mut`，

### 2.2 悬挂引用 Dangling References

# 3 The Slice Type
另一个不是没有所有权的是 *切片*。切片让你可以引用到集合中连续的元素序列，而不是整个集合。
这里有小问题：编写一个函数，这个函数必须要使用一个字符串并起返回这个在这个字符串中找到的第一个单词。如果这个函数没有在这个字符串中找到一个空格，那么整个字符串就被看作是一个单词，那么就要返回整个字符串。
让我们想想这个函数的签名：
```rust
fn first_word(s : &String) -> ?
```

### String Slices

###### String Literals Are Slices

##### String Slices as Parameters

### Other Slices


### Summary

